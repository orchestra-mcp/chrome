package generator

import (
	"fmt"
	"sort"
	"strings"

	"github.com/orchestra-mcp/chrome/src/types"
)

// GenerateContentScripts produces TypeScript source for content-scripts.ts.
// Each script definition is exported as a typed array of content script configs.
func GenerateContentScripts(scripts []types.ChromeContentScriptDef) string {
	var b strings.Builder
	b.WriteString("// Auto-generated by orchestra/chrome plugin. Do not edit.\n\n")
	b.WriteString("export interface ContentScriptDef {\n")
	b.WriteString("  id: string;\n")
	b.WriteString("  pluginId: string;\n")
	b.WriteString("  entry: string;\n")
	b.WriteString("  matches: string[];\n")
	b.WriteString("  runAt: string;\n")
	b.WriteString("  allFrames: boolean;\n")
	b.WriteString("}\n\n")

	// Sort by priority for deterministic output.
	sort.Slice(scripts, func(i, j int) bool { return scripts[i].Priority < scripts[j].Priority })

	b.WriteString("export const contentScripts: ContentScriptDef[] = [\n")
	for _, s := range scripts {
		b.WriteString("  {\n")
		b.WriteString(fmt.Sprintf("    id: %q,\n", s.ID))
		b.WriteString(fmt.Sprintf("    pluginId: %q,\n", s.PluginID))
		b.WriteString(fmt.Sprintf("    entry: %q,\n", s.Entry))
		b.WriteString(fmt.Sprintf("    matches: [%s],\n", formatStringArray(s.Matches)))
		b.WriteString(fmt.Sprintf("    runAt: %q,\n", normalizeRunAt(s.RunAt)))
		b.WriteString(fmt.Sprintf("    allFrames: %t,\n", s.AllFrames))
		b.WriteString("  },\n")
	}
	b.WriteString("];\n")

	return b.String()
}

// formatStringArray formats a Go string slice as a JS array content string.
func formatStringArray(items []string) string {
	quoted := make([]string, len(items))
	for i, item := range items {
		quoted[i] = fmt.Sprintf("%q", item)
	}
	return strings.Join(quoted, ", ")
}
