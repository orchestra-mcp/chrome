package generator

import (
	"fmt"
	"sort"
	"strings"

	"github.com/orchestra-mcp/chrome/src/types"
)

// GeneratePluginViews produces TypeScript source for plugin-views.ts.
// Each view, tab, and status bar item gets a lazy React.lazy(() => import()) call.
func GeneratePluginViews(
	views []types.ChromeViewDef,
	tabs []types.ChromeTabDef,
	statusBar []types.ChromeStatusBarDef,
) string {
	var b strings.Builder
	b.WriteString("// Auto-generated by orchestra/chrome plugin. Do not edit.\n")
	b.WriteString("import { lazy } from 'react';\n\n")

	// Sidebar/panel views sorted by priority.
	sort.Slice(views, func(i, j int) bool { return views[i].Priority < views[j].Priority })
	b.WriteString("export const pluginViews = [\n")
	for _, v := range views {
		b.WriteString(fmt.Sprintf("  {\n    id: %q,\n    pluginId: %q,\n", v.ID, v.PluginID))
		b.WriteString(fmt.Sprintf("    component: lazy(() => import(%q)),\n", v.Component))
		b.WriteString(fmt.Sprintf("    panel: %q,\n    title: %q,\n    icon: %q,\n", v.Panel, v.Title, v.Icon))
		b.WriteString(fmt.Sprintf("    priority: %d,\n", v.Priority))
		if v.HasSearch {
			b.WriteString(fmt.Sprintf("    hasSearch: true,\n    searchPlaceholder: %q,\n", v.SearchPlaceholder))
		}
		if v.When != "" {
			b.WriteString(fmt.Sprintf("    when: %q,\n", v.When))
		}
		writeHeaderActions(&b, v.HeaderActions)
		b.WriteString("  },\n")
	}
	b.WriteString("] as const;\n\n")

	// Tabs sorted by priority.
	sort.Slice(tabs, func(i, j int) bool { return tabs[i].Priority < tabs[j].Priority })
	b.WriteString("export const pluginTabs = [\n")
	for _, t := range tabs {
		b.WriteString(fmt.Sprintf("  {\n    id: %q,\n    pluginId: %q,\n", t.ID, t.PluginID))
		b.WriteString(fmt.Sprintf("    component: lazy(() => import(%q)),\n", t.Component))
		b.WriteString(fmt.Sprintf("    title: %q,\n    icon: %q,\n", t.Title, t.Icon))
		b.WriteString(fmt.Sprintf("    pattern: %q,\n    closable: %t,\n    priority: %d,\n", t.Pattern, t.Closable, t.Priority))
		b.WriteString("  },\n")
	}
	b.WriteString("] as const;\n\n")

	// Status bar items sorted by priority.
	sort.Slice(statusBar, func(i, j int) bool { return statusBar[i].Priority < statusBar[j].Priority })
	b.WriteString("export const pluginStatusBar = [\n")
	for _, s := range statusBar {
		b.WriteString(fmt.Sprintf("  {\n    id: %q,\n    pluginId: %q,\n", s.ID, s.PluginID))
		b.WriteString(fmt.Sprintf("    component: lazy(() => import(%q)),\n", s.Component))
		b.WriteString(fmt.Sprintf("    alignment: %q,\n    priority: %d,\n", s.Alignment, s.Priority))
		b.WriteString("  },\n")
	}
	b.WriteString("] as const;\n")

	return b.String()
}

func writeHeaderActions(b *strings.Builder, actions []types.HeaderActionDef) {
	if len(actions) == 0 {
		return
	}
	b.WriteString("    headerActions: [\n")
	for _, a := range actions {
		b.WriteString(fmt.Sprintf("      { id: %q, icon: %q, title: %q },\n", a.ID, a.Icon, a.Title))
	}
	b.WriteString("    ],\n")
}
